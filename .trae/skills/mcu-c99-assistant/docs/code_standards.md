# 代码编写规范

## C99标准遵循

### 标准特性

- **变量声明**：支持在代码块内任意位置声明变量
- **复合字面量**：支持 `(struct { int x; int y; }) {1, 2}` 形式的复合字面量
- **变长数组**：支持 `int arr[n];` 形式的变长数组
- **内联函数**：使用 `inline` 关键字定义内联函数
- **_Bool 类型**：支持布尔类型
- **stdint.h**：使用标准整数类型定义
- **stdbool.h**：使用标准布尔类型定义
- **complex.h**：支持复数运算

### 编译器扩展

- **GCC扩展**：仅在必要时使用，且需添加条件编译
- **Keil扩展**：注意与其他编译器的兼容性
- **SDCC扩展**：针对8051系列的特殊扩展

## 代码风格

### 缩进与空格

- **缩进**：使用4个空格进行缩进，不使用制表符
- **大括号**：使用K&R风格，左大括号与语句在同一行
- **空格**：
  - 操作符两侧添加空格
  - 逗号后添加空格
  - 分号后添加空格（一行多条语句时）
  - 函数参数列表中，逗号后添加空格

### 命名规范

- **文件命名**：使用小写字母和下划线，如 `gpio_driver.c`
- **函数命名**：使用小写字母和下划线，如 `gpio_init()`
- **变量命名**：使用小写字母和下划线，如 `led_state`
- **常量命名**：使用大写字母和下划线，如 `MAX_BUFFER_SIZE`
- **宏定义**：使用大写字母和下划线，如 `GPIO_MODE_OUTPUT`
- **结构体命名**：使用驼峰命名法，如 `GPIO_Config`
- **枚举命名**：使用驼峰命名法，如 `PinMode`

### 注释规范

- **文件头部**：每个文件头部添加版权和功能说明
- **函数注释**：每个函数添加功能、参数、返回值说明
- **代码注释**：复杂逻辑添加注释说明
- **注释格式**：使用 `/* */` 或 `//`，保持风格一致

## 代码结构

### 文件组织

- **头文件**：`.h` 文件，包含声明和宏定义
- **源文件**：`.c` 文件，包含实现
- **模块划分**：按功能模块划分文件

### 函数设计

- **函数长度**：单个函数不超过50行
- **函数参数**：参数个数不超过5个
- **函数职责**：每个函数只负责一个功能
- **返回值**：明确函数返回值的含义

### 变量管理

- **作用域**：尽量减小变量作用域
- **初始化**：变量定义时进行初始化
- **静态变量**：谨慎使用静态变量
- **全局变量**：尽量避免使用全局变量，如必须使用，添加 `g_` 前缀

## 编程实践

### 内存管理

- **栈内存**：避免在栈上分配大数组
- **堆内存**：谨慎使用动态内存分配
- **内存对齐**：注意数据对齐要求
- **内存泄漏**：确保动态分配的内存被正确释放

### 错误处理

- **错误码**：使用枚举定义错误码
- **错误检查**：及时检查函数返回值
- **错误处理**：对错误进行适当处理，避免程序崩溃
- **日志记录**：关键错误进行日志记录

### 性能优化

- **算法选择**：选择合适的算法和数据结构
- **代码优化**：避免不必要的计算和内存访问
- **编译器优化**：合理使用编译优化选项
- **硬件特性**：充分利用硬件特性进行优化

### 安全性

- **缓冲区溢出**：避免缓冲区溢出
- **指针安全**：避免空指针和野指针
- **输入验证**：对输入数据进行验证
- **边界检查**：检查数组和缓冲区边界

## 代码示例

### 函数定义示例

```c
/**
 * @brief GPIO初始化函数
 * @param pin 引脚编号
 * @param mode 引脚模式
 * @return 0 - 成功，非0 - 失败
 */
int gpio_init(uint32_t pin, uint8_t mode) {
    if (pin >= MAX_PIN_NUMBER) {
        return -1;  // 引脚编号无效
    }
    
    // 配置引脚模式
    if (mode == GPIO_MODE_OUTPUT) {
        // 配置为输出模式
        GPIO->CRL &= ~(0x0F << (pin * 4));
        GPIO->CRL |= (0x03 << (pin * 4));
    } else if (mode == GPIO_MODE_INPUT) {
        // 配置为输入模式
        GPIO->CRL &= ~(0x0F << (pin * 4));
        GPIO->CRL |= (0x04 << (pin * 4));
    }
    
    return 0;
}
```

### 结构体定义示例

```c
/**
 * @brief GPIO配置结构体
 */
typedef struct {
    uint32_t pin;      // 引脚编号
    uint8_t mode;      // 引脚模式
    uint8_t speed;     // 引脚速度
    uint8_t pull;      // 上下拉配置
} GPIO_Config;

/**
 * @brief UART配置结构体
 */
typedef struct {
    uint32_t baudrate;  // 波特率
    uint8_t databits;   // 数据位
    uint8_t stopbits;   // 停止位
    uint8_t parity;     // 校验位
} UART_Config;
```

### 宏定义示例

```c
// 引脚模式定义
#define GPIO_MODE_INPUT      0x00  // 输入模式
#define GPIO_MODE_OUTPUT     0x01  // 输出模式
#define GPIO_MODE_AF         0x02  // 复用功能模式
#define GPIO_MODE_ANALOG     0x03  // 模拟模式

// 引脚速度定义
#define GPIO_SPEED_2MHZ      0x01  // 2MHz
#define GPIO_SPEED_10MHZ     0x02  // 10MHz
#define GPIO_SPEED_50MHZ     0x03  // 50MHz

// 上下拉配置
#define GPIO_PULL_NONE       0x00  // 无上下拉
#define GPIO_PULL_UP         0x01  // 上拉
#define GPIO_PULL_DOWN       0x02  // 下拉
```

### 错误处理示例

```c
/**
 * @brief 错误码定义
 */
typedef enum {
    ERROR_NONE = 0,        // 无错误
    ERROR_PARAM = -1,      // 参数错误
    ERROR_TIMEOUT = -2,    // 超时错误
    ERROR_HARDWARE = -3,   // 硬件错误
    ERROR_MEMORY = -4,     // 内存错误
} ErrorCode;

/**
 * @brief 串口发送数据
 * @param data 数据缓冲区
 * @param length 数据长度
 * @return 错误码
 */
ErrorCode uart_send(const uint8_t *data, uint32_t length) {
    if (data == NULL || length == 0) {
        return ERROR_PARAM;
    }
    
    uint32_t timeout = 1000;  // 1000ms超时
    
    for (uint32_t i = 0; i < length; i++) {
        // 等待发送缓冲区为空
        while (!(UART->SR & UART_SR_TXE)) {
            if (--timeout == 0) {
                return ERROR_TIMEOUT;
            }
        }
        
        // 发送数据
        UART->DR = data[i];
    }
    
    // 等待发送完成
    while (!(UART->SR & UART_SR_TC)) {
        if (--timeout == 0) {
            return ERROR_TIMEOUT;
        }
    }
    
    return ERROR_NONE;
}
```

## 代码审查

### 审查要点

1. **代码风格**：是否符合代码风格规范
2. **逻辑正确性**：代码逻辑是否正确
3. **错误处理**：是否有适当的错误处理
4. **性能优化**：是否有性能优化空间
5. **安全性**：是否存在安全隐患
6. **可维护性**：代码是否易于维护
7. **可移植性**：代码是否具有可移植性

### 审查工具

- **静态分析工具**：如Cppcheck、SonarQube
- **代码格式化工具**：如clang-format
- **版本控制工具**：如Git，用于代码对比

## 最佳实践

1. **遵循C99标准**：使用标准C语言特性，避免依赖编译器扩展
2. **模块化设计**：将代码划分为功能明确的模块
3. **代码复用**：提取公共代码为函数或宏
4. **测试驱动**：编写测试代码验证功能
5. **文档完善**：为代码添加详细注释和文档
6. **版本控制**：使用Git进行版本管理
7. **代码审查**：定期进行代码审查
8. **持续集成**：使用CI/CD工具进行自动测试

## 常见问题

### 代码风格问题

- **缩进不一致**：使用统一的缩进风格
- **命名不规范**：遵循命名规范
- **注释不足**：添加适当的注释
- **代码冗长**：拆分长函数，提取重复代码

### 性能问题

- **不必要的计算**：避免重复计算
- **内存泄漏**：及时释放动态分配的内存
- **过度使用全局变量**：减少全局变量的使用
- **低效算法**：选择合适的算法和数据结构

### 安全问题

- **缓冲区溢出**：使用安全的字符串操作函数
- **空指针解引用**：检查指针是否为空
- **整数溢出**：注意整数运算的溢出问题
- **未初始化变量**：初始化所有变量

### 可移植性问题

- **依赖特定编译器**：避免使用编译器特定的扩展
- **依赖特定硬件**：使用硬件抽象层
- **字节序问题**：注意处理字节序差异
- **数据对齐问题**：注意数据对齐要求